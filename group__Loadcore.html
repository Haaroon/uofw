<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>uOFW: Loadcore Module</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">uOFW
   
   </div>
   <div id="projectbrief">Reverse engineered PSP kernel 6.60.</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Loadcore Module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDirectCall.html">DirectCall</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSyscall.html">Syscall</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionSceStub.html">SceStub</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceVariableStub.html">SceVariableStub</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceBootCallback.html">SceBootCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceStubLibrary.html">SceStubLibrary</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceResidentLibrary.html">SceResidentLibrary</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCoreProtectInfo.html">SceLoadCoreProtectInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCoreBootModuleInfo.html">SceLoadCoreBootModuleInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCoreBootInfo.html">SceLoadCoreBootInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceModule.html">SceModule</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceSyscallTable.html">SceSyscallTable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCore.html">SceLoadCore</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabce5652c4e61f4d009c6c8a3362f30c1">LIBRARY_VERSION_MINOR</a>&#160;&#160;&#160;(0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gab01a311c151ae89e396968b30403a801">LIBRARY_VERSION_MAJOR</a>&#160;&#160;&#160;(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaedd8cb264d52ac2da5a2896617e3c64f">LIBRARY_VERSION_NUMBER_CATEGORY_SIZE</a>&#160;&#160;&#160;(2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga2bc3993d7f85386f95fa6fa43be28071">LIBRARY_ENTRY_TABLE_OLD_LEN</a>&#160;&#160;&#160;(4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaad50d562baa3b27ce2edba3d0786c68f">LIBRARY_ENTRY_TABLE_NEW_LEN</a>&#160;&#160;&#160;(5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaf4228ecc6e2a07beaf36dc11388010ba">STUB_LIBRARY_ENTRY_TABLE_OLD_LEN</a>&#160;&#160;&#160;(6)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga9eecbbcaa957b79a633619c3cd235230">STUB_LIBRARY_ENTRY_TABLE_NEW_LEN</a>&#160;&#160;&#160;(7)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gac2659f67c57d64bd8dccf6b9ef044350">LOADCORE_LIB_HASH_TABLE_SIZE</a>&#160;&#160;&#160;(128)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga4dc2ea4c871facd3ba43095b78d67541">SCE_BOOT_CALLBACK_FUNCTION_QUEUED</a>&#160;&#160;&#160;(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaa6a6e66d2215ad31f49a6ae43f0c7880">SCE_PROTECT_INFO_STATE_IS_ALLOCATED</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga358934f1d906e6500e9c25437ad051fa">SCE_PROTECT_INFO_TYPE_FILE_NAME</a>&#160;&#160;&#160;(0x2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga513eeed6c82ce877f9210b35351bfbf5">SCE_PROTECT_INFO_TYPE_VSH_PARAM</a>&#160;&#160;&#160;(0x4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga3a1d52968516fd2a5fa2c6057a8b8440">SCE_PROTECT_INFO_TYPE_DISC_IMAGE</a>&#160;&#160;&#160;(0x40)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga98e818579b4eb5e3dab698579cf761da">SCE_PROTECT_INFO_TYPE_NPDRM_DATA</a>&#160;&#160;&#160;(0x80)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga1cb3f8ab1b5f1ca92d3b9c3b3c3a7f2c">SCE_PROTECT_INFO_TYPE_USER_PARAM</a>&#160;&#160;&#160;(0x100)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga064c6f899777c70b9c3c0006d01ff847">SCE_PROTECT_INFO_TYPE_PARAM_SFO</a>&#160;&#160;&#160;(0x400)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga841d1f23ad9881cd37010137d4d9152a">GET_PROTECT_INFO_STATE</a>(attr)&#160;&#160;&#160;((u32)(attr) &gt;&gt; 16)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga4790cee80f516a6b0c8b307691f9df0c">SET_PROTECT_INFO_STATE</a>(state, src)&#160;&#160;&#160;(((state) &lt;&lt; 16) | (src))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gab3d2855309cc2ec094b642bea92ffc0d">REMOVE_PROTECT_INFO_STATE</a>(state, src)&#160;&#160;&#160;((~((state) &lt;&lt; 16)) &amp; (src))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga1f48480d7acf0e5cae8bce256ccf7c4a">GET_PROTECT_INFO_TYPE</a>(attr)&#160;&#160;&#160;((attr) &amp; 0xFFFF)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga3b8302cae9a68bcad9e065de8d81f5cc">SET_PROTECT_INFO_TYPE</a>(type, src)&#160;&#160;&#160;(((type) &amp; 0xFFFF) | (src))</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef s32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaaaf9e069ea1f8e0e6a0b70898afc3270">SceKernelBootCallbackFunction</a> )(void *data, s32 arg, void *opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSceStubLibrary.html">SceStubLibrary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabc93f0892a9ce1a492817326c5c5c8af">SceStubLibrary</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSceResidentLibrary.html">SceResidentLibrary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaf0200fd1d0b6bcf4be034c4d2ee4c7c6">SceResidentLibrary</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSceModule.html">SceModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga0cad866437598c858937aaf67e75354b">SceModule</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSceSyscallTable.html">SceSyscallTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga939bb8b59b665de820d8d98f92882f23">SceSyscallTable</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga95f11f1d387b7f449d120152ebdd78da">SceExecFileAttr</a> { <a class="el" href="group__Loadcore.html#gga95f11f1d387b7f449d120152ebdd78daa2635299e99ea51f197742dc25d9e7579">SCE_EXEC_FILE_COMPRESSED</a> =  0x1, 
<a class="el" href="group__Loadcore.html#gga95f11f1d387b7f449d120152ebdd78daa9dc2ea24ff1f515ac7ab448389287f3d">SCE_EXEC_FILE_ELF</a> =  0x2, 
<a class="el" href="group__Loadcore.html#gga95f11f1d387b7f449d120152ebdd78daab9da304786edd19dcd9ac2799ed128ec">SCE_EXEC_FILE_GZIP_OVERLAP</a> =  0x8, 
<a class="el" href="group__Loadcore.html#gga95f11f1d387b7f449d120152ebdd78daa8273376737c53e1c33867fde57ea1642">SCE_EXEC_FILE_KL4E_COMPRESSED</a> =  0x200
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaf2f41164f95332df5f4cdfc55724142d">SceExecFileModeAttr</a> { <a class="el" href="group__Loadcore.html#ggaf2f41164f95332df5f4cdfc55724142da2e05bd98289d259703e35d844f1b0a7f">SCE_EXEC_FILE_DECRYPT</a> =  0, 
<a class="el" href="group__Loadcore.html#ggaf2f41164f95332df5f4cdfc55724142da12007ebccfbbd42bb2db7defc9d76ca5">SCE_EXEC_FILE_NO_HEADER_COMPRESSION</a> =  1, 
<a class="el" href="group__Loadcore.html#ggaf2f41164f95332df5f4cdfc55724142da313d43bac909fc9039fd2292fc9babfc">SCE_EXEC_FILE_NO_COMPRESSION</a> =  2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gadd729faad5a09adb92f9099655dbccef">SceExecFileElfType</a> { <a class="el" href="group__Loadcore.html#ggadd729faad5a09adb92f9099655dbccefada14f19afa4a1b965e690d316189be63">SCE_EXEC_FILE_TYPE_INVALID_ELF</a> =  -1, 
<a class="el" href="group__Loadcore.html#ggadd729faad5a09adb92f9099655dbccefaca76b40bd50defed6c3b676f0dca9413">SCE_EXEC_FILE_TYPE_PRX</a> =  1, 
<a class="el" href="group__Loadcore.html#ggadd729faad5a09adb92f9099655dbccefa95388c00f97c01ef0408e76ace88f924">SCE_EXEC_FILE_TYPE_PRX_2</a> =  2, 
<a class="el" href="group__Loadcore.html#ggadd729faad5a09adb92f9099655dbccefae9ec646eaef857a366eb11ba1c484d7e">SCE_EXEC_FILE_TYPE_ELF</a> =  3
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga3a4646a2fd1ce198fa2ec6e11a6d7fc1">SceLibAttr</a> { <br/>
&#160;&#160;<a class="el" href="group__Loadcore.html#gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a6617d512bb4fcff495982ae9c6fd5b08">SCE_LIB_NO_SPECIAL_ATTR</a> =  0x0, 
<a class="el" href="group__Loadcore.html#gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a72abd726e9fd4d7e5a96daf0bf561305">SCE_LIB_AUTO_EXPORT</a> =  0x1, 
<a class="el" href="group__Loadcore.html#gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a3390ddabf6d87ed90c95e7714a89f9f9">SCE_LIB_WEAK_EXPORT</a> =  0x2, 
<a class="el" href="group__Loadcore.html#gga3a4646a2fd1ce198fa2ec6e11a6d7fc1ac854cee6ed7e91f11188b1e1b11a4df1">SCE_LIB_NOLINK_EXPORT</a> =  0x4, 
<br/>
&#160;&#160;<a class="el" href="group__Loadcore.html#gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a58899b8e37207888395c438fc8deef45">SCE_LIB_WEAK_IMPORT</a> =  0x8, 
<a class="el" href="group__Loadcore.html#gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a6c80618f7587629ad51babc32f0e596f">SCE_LIB_SYSCALL_EXPORT</a> =  0x4000, 
<a class="el" href="group__Loadcore.html#gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a2d6c3bfc81bdc0c297a1c13dbb8bfdd1">SCE_LIB_IS_SYSLIB</a> =  0x8000
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga5e1860bc052008fbebde6907abea5919">sceKernelRegisterLibrary</a> (<a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *libEntryTable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga639e2665a0bfc1276b09f0ae597edabe">sceKernelCanReleaseLibrary</a> (<a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *libEntryTable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga8f03e8233ed3334f49c9253bb94cbb7f">sceKernelLinkLibraryEntries</a> (<a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *libStubTable, u32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga8025675e3f76dd3de33abe290428660c">sceKernelUnLinkLibraryEntries</a> (<a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *libStubTable, u32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gac154c992eeedc2eaa0088776d44a3cae">sceKernelLoadModuleBootLoadCore</a> (<a class="el" href="structSceLoadCoreBootModuleInfo.html">SceLoadCoreBootModuleInfo</a> *bootModInfo, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execInfo, SceUID *modMemId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga06690dfe9537a4eb1ab8942d4a5e0a1d">sceKernelLoadCoreLock</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gae05f15d19f46b074ae730c86c953db26">sceKernelLoadCoreUnlock</a> (s32 intrState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaf43974f8ec77ca5ca2e90e025327fa55">sceKernelRegisterLibraryForUser</a> (<a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *libEntryTable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga1ff3206fbd6adf5e7dfb03efb67258e6">sceKernelReleaseLibrary</a> (<a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *libEntryTable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gafe06ce57f0c47128178c0d77fd6f3a45">sceKernelLinkLibraryEntriesForUser</a> (<a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *libStubTable, u32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga8f0ad0656e221ae09a1da75722e8e0a2">sceKernelLinkLibraryEntriesWithModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod, <a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *libStubTable, u32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga6247573c87614bff810f3275d45a8a56">sceKernelMaskLibraryEntries</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceLoadCore.html">SceLoadCore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga35b67da694093937b29662cb1fa0bd80">sceKernelQueryLoadCoreCB</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gac4d5e3489d68d046ec7d07af2d8c6ef4">sceKernelSetBootCallbackLevel</a> (<a class="el" href="group__Loadcore.html#gaaaf9e069ea1f8e0e6a0b70898afc3270">SceKernelBootCallbackFunction</a> bootCBFunc, u32 flag, s32 *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga1d6500012c146066884c19e5b2ba4ade">sceKernelLoadCoreMode</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga7f6a2494ffb0470b0f9599e090e50831">sceKernelCheckPspConfig</a> (u8 *file, u32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga4085a25a1930eff036090a5102aec28d">sceKernelLoadRebootBin</a> (u8 *file, u32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga2b218b4b1d73fb5e70245175b9ab3de2">sceKernelSegmentChecksum</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gadc44f347ed1d715e36335fefaf55c73d">sceKernelCheckExecFile</a> (u8 *buf, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga088333b921044f7835c1d6ec9b2319af">sceKernelProbeExecutableObject</a> (u8 *buf, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabb7052742d9d25460b816091fdebe838">sceKernelLoadExecutableObject</a> (u8 *buf, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gadaf7561a272d3b2cf5affab96c72145e">sceKernelCreateModule</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaaaf39d993dcafa17af01e1ca7c194a18">sceKernelAssignModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execFileInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gac2413650b3190085fd16d5e0e8f501e1">sceKernelReleaseModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gae9cffa3669a80cbdb0fec14c7cc1b3ee">sceKernelGetModuleIdListForKernel</a> (SceUID *modIdList, u32 size, u32 *modCount, u32 userModsOnly)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga30d19f5c2935c6f97b48c6e106c7a34c">sceKernelGetModuleFromUID</a> (SceUID uid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga4f953301858af828e5e11084c3e2806f">sceKernelDeleteModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabac93803cbf0181b02ab23d7d7220040">sceKernelCreateAssignModule</a> (<a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execFileInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga78f11263a69a222a15be9977fce1af50">sceKernelRegisterModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaebbaa6caea1fe4f07e4f0a9436f67147">sceKernelFindModuleByName</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga60135c1de86354096f49bc42360c8c6a">sceKernelFindModuleByAddress</a> (u32 addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabc7d802b414800306356518437437ea8">sceKernelGetModuleGPByAddressForKernel</a> (u32 addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gad7965536d1d3b54d72836100caf6b57d">sceKernelFindModuleByUID</a> (SceUID uid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga55a39d58f03c98c1e7deee348c218ed8">sceKernelGetModuleListWithAlloc</a> (u32 *modCount)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Copyright (C) 2011, 2012, 2013 The uOFW team See the file COPYING for copying permission.<br/>
 Module loader and library import/export manager. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gabce5652c4e61f4d009c6c8a3362f30c1"></a><!-- doxytag: member="loadcore.h::LIBRARY_VERSION_MINOR" ref="gabce5652c4e61f4d009c6c8a3362f30c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#gabce5652c4e61f4d009c6c8a3362f30c1">LIBRARY_VERSION_MINOR</a>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Library number category minor. </p>

</div>
</div>
<a class="anchor" id="gab01a311c151ae89e396968b30403a801"></a><!-- doxytag: member="loadcore.h::LIBRARY_VERSION_MAJOR" ref="gab01a311c151ae89e396968b30403a801" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#gab01a311c151ae89e396968b30403a801">LIBRARY_VERSION_MAJOR</a>&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Library number category major. </p>

</div>
</div>
<a class="anchor" id="gaedd8cb264d52ac2da5a2896617e3c64f"></a><!-- doxytag: member="loadcore.h::LIBRARY_VERSION_NUMBER_CATEGORY_SIZE" ref="gaedd8cb264d52ac2da5a2896617e3c64f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#gaedd8cb264d52ac2da5a2896617e3c64f">LIBRARY_VERSION_NUMBER_CATEGORY_SIZE</a>&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Current number category size for libraries. </p>

</div>
</div>
<a class="anchor" id="ga2bc3993d7f85386f95fa6fa43be28071"></a><!-- doxytag: member="loadcore.h::LIBRARY_ENTRY_TABLE_OLD_LEN" ref="ga2bc3993d7f85386f95fa6fa43be28071" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga2bc3993d7f85386f95fa6fa43be28071">LIBRARY_ENTRY_TABLE_OLD_LEN</a>&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The length of the old resident library entry table format (without the members unk16 - uk19). </p>

</div>
</div>
<a class="anchor" id="gaad50d562baa3b27ce2edba3d0786c68f"></a><!-- doxytag: member="loadcore.h::LIBRARY_ENTRY_TABLE_NEW_LEN" ref="gaad50d562baa3b27ce2edba3d0786c68f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#gaad50d562baa3b27ce2edba3d0786c68f">LIBRARY_ENTRY_TABLE_NEW_LEN</a>&#160;&#160;&#160;(5)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The length of the new resident library entry table format (including the members unk16 - unk19). </p>

</div>
</div>
<a class="anchor" id="gaf4228ecc6e2a07beaf36dc11388010ba"></a><!-- doxytag: member="loadcore.h::STUB_LIBRARY_ENTRY_TABLE_OLD_LEN" ref="gaf4228ecc6e2a07beaf36dc11388010ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#gaf4228ecc6e2a07beaf36dc11388010ba">STUB_LIBRARY_ENTRY_TABLE_OLD_LEN</a>&#160;&#160;&#160;(6)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The length of the old stub library entry table format (without the member unk24). </p>

</div>
</div>
<a class="anchor" id="ga9eecbbcaa957b79a633619c3cd235230"></a><!-- doxytag: member="loadcore.h::STUB_LIBRARY_ENTRY_TABLE_NEW_LEN" ref="ga9eecbbcaa957b79a633619c3cd235230" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga9eecbbcaa957b79a633619c3cd235230">STUB_LIBRARY_ENTRY_TABLE_NEW_LEN</a>&#160;&#160;&#160;(7)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The length of the new stub library entry table format (including the member unk24). </p>

</div>
</div>
<a class="anchor" id="gac2659f67c57d64bd8dccf6b9ef044350"></a><!-- doxytag: member="loadcore.h::LOADCORE_LIB_HASH_TABLE_SIZE" ref="gac2659f67c57d64bd8dccf6b9ef044350" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#gac2659f67c57d64bd8dccf6b9ef044350">LOADCORE_LIB_HASH_TABLE_SIZE</a>&#160;&#160;&#160;(128)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The possible number of libraries with different hash values. </p>

</div>
</div>
<a class="anchor" id="ga4dc2ea4c871facd3ba43095b78d67541"></a><!-- doxytag: member="loadcore.h::SCE_BOOT_CALLBACK_FUNCTION_QUEUED" ref="ga4dc2ea4c871facd3ba43095b78d67541" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga4dc2ea4c871facd3ba43095b78d67541">SCE_BOOT_CALLBACK_FUNCTION_QUEUED</a>&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates that a boot callback function was added to the internal boot callback queue. </p>

</div>
</div>
<a class="anchor" id="gaa6a6e66d2215ad31f49a6ae43f0c7880"></a><!-- doxytag: member="loadcore.h::SCE_PROTECT_INFO_STATE_IS_ALLOCATED" ref="gaa6a6e66d2215ad31f49a6ae43f0c7880" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#gaa6a6e66d2215ad31f49a6ae43f0c7880">SCE_PROTECT_INFO_STATE_IS_ALLOCATED</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The protected information block is allocated. </p>

</div>
</div>
<a class="anchor" id="ga358934f1d906e6500e9c25437ad051fa"></a><!-- doxytag: member="loadcore.h::SCE_PROTECT_INFO_TYPE_FILE_NAME" ref="ga358934f1d906e6500e9c25437ad051fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga358934f1d906e6500e9c25437ad051fa">SCE_PROTECT_INFO_TYPE_FILE_NAME</a>&#160;&#160;&#160;(0x2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates the type of the protected information block is a file name. </p>

</div>
</div>
<a class="anchor" id="ga513eeed6c82ce877f9210b35351bfbf5"></a><!-- doxytag: member="loadcore.h::SCE_PROTECT_INFO_TYPE_VSH_PARAM" ref="ga513eeed6c82ce877f9210b35351bfbf5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga513eeed6c82ce877f9210b35351bfbf5">SCE_PROTECT_INFO_TYPE_VSH_PARAM</a>&#160;&#160;&#160;(0x4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates the type of the protected information block is a VSH param. </p>

</div>
</div>
<a class="anchor" id="ga3a1d52968516fd2a5fa2c6057a8b8440"></a><!-- doxytag: member="loadcore.h::SCE_PROTECT_INFO_TYPE_DISC_IMAGE" ref="ga3a1d52968516fd2a5fa2c6057a8b8440" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga3a1d52968516fd2a5fa2c6057a8b8440">SCE_PROTECT_INFO_TYPE_DISC_IMAGE</a>&#160;&#160;&#160;(0x40)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates the type of the protected information block is a disc image. </p>

</div>
</div>
<a class="anchor" id="ga98e818579b4eb5e3dab698579cf761da"></a><!-- doxytag: member="loadcore.h::SCE_PROTECT_INFO_TYPE_NPDRM_DATA" ref="ga98e818579b4eb5e3dab698579cf761da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga98e818579b4eb5e3dab698579cf761da">SCE_PROTECT_INFO_TYPE_NPDRM_DATA</a>&#160;&#160;&#160;(0x80)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates protected information block belongs to a NPDRM package. </p>

</div>
</div>
<a class="anchor" id="ga1cb3f8ab1b5f1ca92d3b9c3b3c3a7f2c"></a><!-- doxytag: member="loadcore.h::SCE_PROTECT_INFO_TYPE_USER_PARAM" ref="ga1cb3f8ab1b5f1ca92d3b9c3b3c3a7f2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga1cb3f8ab1b5f1ca92d3b9c3b3c3a7f2c">SCE_PROTECT_INFO_TYPE_USER_PARAM</a>&#160;&#160;&#160;(0x100)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates the type of the protected information block is a user param. </p>

</div>
</div>
<a class="anchor" id="ga064c6f899777c70b9c3c0006d01ff847"></a><!-- doxytag: member="loadcore.h::SCE_PROTECT_INFO_TYPE_PARAM_SFO" ref="ga064c6f899777c70b9c3c0006d01ff847" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga064c6f899777c70b9c3c0006d01ff847">SCE_PROTECT_INFO_TYPE_PARAM_SFO</a>&#160;&#160;&#160;(0x400)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates the type of the protected information block is a param.sfo. </p>

</div>
</div>
<a class="anchor" id="ga841d1f23ad9881cd37010137d4d9152a"></a><!-- doxytag: member="loadcore.h::GET_PROTECT_INFO_STATE" ref="ga841d1f23ad9881cd37010137d4d9152a" args="(attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga841d1f23ad9881cd37010137d4d9152a">GET_PROTECT_INFO_STATE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">attr</td><td>)</td>
          <td>&#160;&#160;&#160;((u32)(attr) &gt;&gt; 16)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the state of a protected information block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4790cee80f516a6b0c8b307691f9df0c"></a><!-- doxytag: member="loadcore.h::SET_PROTECT_INFO_STATE" ref="ga4790cee80f516a6b0c8b307691f9df0c" args="(state, src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga4790cee80f516a6b0c8b307691f9df0c">SET_PROTECT_INFO_STATE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">state, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((state) &lt;&lt; 16) | (src))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a new state of a protected information block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The new state to set. </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3d2855309cc2ec094b642bea92ffc0d"></a><!-- doxytag: member="loadcore.h::REMOVE_PROTECT_INFO_STATE" ref="gab3d2855309cc2ec094b642bea92ffc0d" args="(state, src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#gab3d2855309cc2ec094b642bea92ffc0d">REMOVE_PROTECT_INFO_STATE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">state, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((~((state) &lt;&lt; 16)) &amp; (src))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove a state entry of a protected information block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state entry to remove. </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f48480d7acf0e5cae8bce256ccf7c4a"></a><!-- doxytag: member="loadcore.h::GET_PROTECT_INFO_TYPE" ref="ga1f48480d7acf0e5cae8bce256ccf7c4a" args="(attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga1f48480d7acf0e5cae8bce256ccf7c4a">GET_PROTECT_INFO_TYPE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">attr</td><td>)</td>
          <td>&#160;&#160;&#160;((attr) &amp; 0xFFFF)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the type of a protected information block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b8302cae9a68bcad9e065de8d81f5cc"></a><!-- doxytag: member="loadcore.h::SET_PROTECT_INFO_TYPE" ref="ga3b8302cae9a68bcad9e065de8d81f5cc" args="(type, src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Loadcore.html#ga3b8302cae9a68bcad9e065de8d81f5cc">SET_PROTECT_INFO_TYPE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((type) &amp; 0xFFFF) | (src))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the type of a protected information block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The new type to set. </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaaaf9e069ea1f8e0e6a0b70898afc3270"></a><!-- doxytag: member="loadcore.h::SceKernelBootCallbackFunction" ref="gaaaf9e069ea1f8e0e6a0b70898afc3270" args=")(void *data, s32 arg, void *opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef s32(* <a class="el" href="group__Loadcore.html#gaaaf9e069ea1f8e0e6a0b70898afc3270">SceKernelBootCallbackFunction</a>)(void *data, s32 arg, void *opt)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Boot Callback function. </p>

</div>
</div>
<a class="anchor" id="gabc93f0892a9ce1a492817326c5c5c8af"></a><!-- doxytag: member="loadcore.h::SceStubLibrary" ref="gabc93f0892a9ce1a492817326c5c5c8af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSceStubLibrary.html">SceStubLibrary</a>  <a class="el" href="structSceStubLibrary.html">SceStubLibrary</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This structure represents a stub library control block. This control block is used to manage a stub library entry table internal. </p>

</div>
</div>
<a class="anchor" id="gaf0200fd1d0b6bcf4be034c4d2ee4c7c6"></a><!-- doxytag: member="loadcore.h::SceResidentLibrary" ref="gaf0200fd1d0b6bcf4be034c4d2ee4c7c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSceResidentLibrary.html">SceResidentLibrary</a>  <a class="el" href="structSceResidentLibrary.html">SceResidentLibrary</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This structure represents a resident library control block. This control block is used to manage a resident library entry table registered to the system. </p>

</div>
</div>
<a class="anchor" id="ga0cad866437598c858937aaf67e75354b"></a><!-- doxytag: member="loadcore.h::SceModule" ref="ga0cad866437598c858937aaf67e75354b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSceModule.html">SceModule</a>  <a class="el" href="structSceModule.html">SceModule</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="structSceModule.html">SceModule</a> structure represents a loaded module in memory. </p>

</div>
</div>
<a class="anchor" id="ga939bb8b59b665de820d8d98f92882f23"></a><!-- doxytag: member="loadcore.h::SceSyscallTable" ref="ga939bb8b59b665de820d8d98f92882f23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSceSyscallTable.html">SceSyscallTable</a>  <a class="el" href="structSceSyscallTable.html">SceSyscallTable</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This structure represents a system call table. Such a table takes care of the exported system calls registered to the system. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga95f11f1d387b7f449d120152ebdd78da"></a><!-- doxytag: member="loadcore.h::SceExecFileAttr" ref="ga95f11f1d387b7f449d120152ebdd78da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Loadcore.html#ga95f11f1d387b7f449d120152ebdd78da">SceExecFileAttr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executable File Attributes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga95f11f1d387b7f449d120152ebdd78daa2635299e99ea51f197742dc25d9e7579"></a><!-- doxytag: member="SCE_EXEC_FILE_COMPRESSED" ref="gga95f11f1d387b7f449d120152ebdd78daa2635299e99ea51f197742dc25d9e7579" args="" -->SCE_EXEC_FILE_COMPRESSED</em>&nbsp;</td><td>
<p>The file is compressed. If SCE_EXEC_FILE_KL4E_COMPRESSED is not set, the file is GZIP compressed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga95f11f1d387b7f449d120152ebdd78daa9dc2ea24ff1f515ac7ab448389287f3d"></a><!-- doxytag: member="SCE_EXEC_FILE_ELF" ref="gga95f11f1d387b7f449d120152ebdd78daa9dc2ea24ff1f515ac7ab448389287f3d" args="" -->SCE_EXEC_FILE_ELF</em>&nbsp;</td><td>
<p>The file is a static ELF. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga95f11f1d387b7f449d120152ebdd78daab9da304786edd19dcd9ac2799ed128ec"></a><!-- doxytag: member="SCE_EXEC_FILE_GZIP_OVERLAP" ref="gga95f11f1d387b7f449d120152ebdd78daab9da304786edd19dcd9ac2799ed128ec" args="" -->SCE_EXEC_FILE_GZIP_OVERLAP</em>&nbsp;</td><td>
<p>The file has GZIP overlap. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga95f11f1d387b7f449d120152ebdd78daa8273376737c53e1c33867fde57ea1642"></a><!-- doxytag: member="SCE_EXEC_FILE_KL4E_COMPRESSED" ref="gga95f11f1d387b7f449d120152ebdd78daa8273376737c53e1c33867fde57ea1642" args="" -->SCE_EXEC_FILE_KL4E_COMPRESSED</em>&nbsp;</td><td>
<p>The file is KL4E compressed. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf2f41164f95332df5f4cdfc55724142d"></a><!-- doxytag: member="loadcore.h::SceExecFileModeAttr" ref="gaf2f41164f95332df5f4cdfc55724142d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Loadcore.html#gaf2f41164f95332df5f4cdfc55724142d">SceExecFileModeAttr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executable File Mode Attributes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaf2f41164f95332df5f4cdfc55724142da2e05bd98289d259703e35d844f1b0a7f"></a><!-- doxytag: member="SCE_EXEC_FILE_DECRYPT" ref="ggaf2f41164f95332df5f4cdfc55724142da2e05bd98289d259703e35d844f1b0a7f" args="" -->SCE_EXEC_FILE_DECRYPT</em>&nbsp;</td><td>
<p>The file is decrypted. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf2f41164f95332df5f4cdfc55724142da12007ebccfbbd42bb2db7defc9d76ca5"></a><!-- doxytag: member="SCE_EXEC_FILE_NO_HEADER_COMPRESSION" ref="ggaf2f41164f95332df5f4cdfc55724142da12007ebccfbbd42bb2db7defc9d76ca5" args="" -->SCE_EXEC_FILE_NO_HEADER_COMPRESSION</em>&nbsp;</td><td>
<p>The file header is not compressed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf2f41164f95332df5f4cdfc55724142da313d43bac909fc9039fd2292fc9babfc"></a><!-- doxytag: member="SCE_EXEC_FILE_NO_COMPRESSION" ref="ggaf2f41164f95332df5f4cdfc55724142da313d43bac909fc9039fd2292fc9babfc" args="" -->SCE_EXEC_FILE_NO_COMPRESSION</em>&nbsp;</td><td>
<p>The file is not compressed. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd729faad5a09adb92f9099655dbccef"></a><!-- doxytag: member="loadcore.h::SceExecFileElfType" ref="gadd729faad5a09adb92f9099655dbccef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Loadcore.html#gadd729faad5a09adb92f9099655dbccef">SceExecFileElfType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The possible ELF type of an executable. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggadd729faad5a09adb92f9099655dbccefada14f19afa4a1b965e690d316189be63"></a><!-- doxytag: member="SCE_EXEC_FILE_TYPE_INVALID_ELF" ref="ggadd729faad5a09adb92f9099655dbccefada14f19afa4a1b965e690d316189be63" args="" -->SCE_EXEC_FILE_TYPE_INVALID_ELF</em>&nbsp;</td><td>
<p>The executable file is not an ELF. Such a file cannot be loaded. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadd729faad5a09adb92f9099655dbccefaca76b40bd50defed6c3b676f0dca9413"></a><!-- doxytag: member="SCE_EXEC_FILE_TYPE_PRX" ref="ggadd729faad5a09adb92f9099655dbccefaca76b40bd50defed6c3b676f0dca9413" args="" -->SCE_EXEC_FILE_TYPE_PRX</em>&nbsp;</td><td>
<p>The executable file is a PRX, a relocatable ELF. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadd729faad5a09adb92f9099655dbccefa95388c00f97c01ef0408e76ace88f924"></a><!-- doxytag: member="SCE_EXEC_FILE_TYPE_PRX_2" ref="ggadd729faad5a09adb92f9099655dbccefa95388c00f97c01ef0408e76ace88f924" args="" -->SCE_EXEC_FILE_TYPE_PRX_2</em>&nbsp;</td><td>
<p>The executable file is a PRX, a relocatable ELF. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadd729faad5a09adb92f9099655dbccefae9ec646eaef857a366eb11ba1c484d7e"></a><!-- doxytag: member="SCE_EXEC_FILE_TYPE_ELF" ref="ggadd729faad5a09adb92f9099655dbccefae9ec646eaef857a366eb11ba1c484d7e" args="" -->SCE_EXEC_FILE_TYPE_ELF</em>&nbsp;</td><td>
<p>The executable file is a static ELF. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a4646a2fd1ce198fa2ec6e11a6d7fc1"></a><!-- doxytag: member="loadcore.h::SceLibAttr" ref="ga3a4646a2fd1ce198fa2ec6e11a6d7fc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Loadcore.html#ga3a4646a2fd1ce198fa2ec6e11a6d7fc1">SceLibAttr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resident/Stub library attributes. Several members can be bitwise OR'ed together. Every library needs to have at least one of those attributes. Resident libraries can have the members SCE_LIB_AUTO_EXPORT, SCE_LIB_WEAK_EXPORT, (SCE_LIB_NOLINK_EXPORT), SCE_LIB_SYSCALL_EXPORT and SCE_LIB_IS_SYSLIB. Stub libraries can have SCE_LIB_NO_SPECIAL_ATTR or SCE_LIB_WEAK_IMPORT. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a6617d512bb4fcff495982ae9c6fd5b08"></a><!-- doxytag: member="SCE_LIB_NO_SPECIAL_ATTR" ref="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a6617d512bb4fcff495982ae9c6fd5b08" args="" -->SCE_LIB_NO_SPECIAL_ATTR</em>&nbsp;</td><td>
<p>The library has no special attributes. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a72abd726e9fd4d7e5a96daf0bf561305"></a><!-- doxytag: member="SCE_LIB_AUTO_EXPORT" ref="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a72abd726e9fd4d7e5a96daf0bf561305" args="" -->SCE_LIB_AUTO_EXPORT</em>&nbsp;</td><td>
<p>Automatically register the library to the system. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a3390ddabf6d87ed90c95e7714a89f9f9"></a><!-- doxytag: member="SCE_LIB_WEAK_EXPORT" ref="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a3390ddabf6d87ed90c95e7714a89f9f9" args="" -->SCE_LIB_WEAK_EXPORT</em>&nbsp;</td><td>
<p>Indicates resident library can be overwritten. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1ac854cee6ed7e91f11188b1e1b11a4df1"></a><!-- doxytag: member="SCE_LIB_NOLINK_EXPORT" ref="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1ac854cee6ed7e91f11188b1e1b11a4df1" args="" -->SCE_LIB_NOLINK_EXPORT</em>&nbsp;</td><td>
<p>Indicates resident library is NOT being linked. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a58899b8e37207888395c438fc8deef45"></a><!-- doxytag: member="SCE_LIB_WEAK_IMPORT" ref="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a58899b8e37207888395c438fc8deef45" args="" -->SCE_LIB_WEAK_IMPORT</em>&nbsp;</td><td>
<p>Load module that references this library even if this library is not registered. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a6c80618f7587629ad51babc32f0e596f"></a><!-- doxytag: member="SCE_LIB_SYSCALL_EXPORT" ref="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a6c80618f7587629ad51babc32f0e596f" args="" -->SCE_LIB_SYSCALL_EXPORT</em>&nbsp;</td><td>
<p>Indicates the use of the SYSCALL technique for linking. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a2d6c3bfc81bdc0c297a1c13dbb8bfdd1"></a><!-- doxytag: member="SCE_LIB_IS_SYSLIB" ref="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a2d6c3bfc81bdc0c297a1c13dbb8bfdd1" args="" -->SCE_LIB_IS_SYSLIB</em>&nbsp;</td><td>
<p>The library is a system library (a mandatory library for all modules). </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga5e1860bc052008fbebde6907abea5919"></a><!-- doxytag: member="loadcore.h::sceKernelRegisterLibrary" ref="ga5e1860bc052008fbebde6907abea5919" args="(SceResidentLibraryEntryTable *libEntryTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga5e1860bc052008fbebde6907abea5919">sceKernelRegisterLibrary</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libEntryTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a resident library's entry table in the system. A resident module can register any number of resident libraries. Note that this function is only meant to register kernel mode resident libraries. In order to register user mode libraries, use <a class="el" href="group__Loadcore.html#gaf43974f8ec77ca5ca2e90e025327fa55">sceKernelRegisterLibraryForUser()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">libEntryTable</td><td>Pointer to the resident library's entry table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga639e2665a0bfc1276b09f0ae597edabe"></a><!-- doxytag: member="loadcore.h::sceKernelCanReleaseLibrary" ref="ga639e2665a0bfc1276b09f0ae597edabe" args="(SceResidentLibraryEntryTable *libEntryTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga639e2665a0bfc1276b09f0ae597edabe">sceKernelCanReleaseLibrary</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libEntryTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if a resident library can be released. This check returns "true" when all corresponding stub libraries at the time of the check have one the following status: a) unlinked b) have the the attribute SCE_LIB_WEAK_IMPORT (they can exist without the resident library being registered).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">libEntryTable</td><td>Pointer to the resident library's entry table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 indicates the library can be released. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f03e8233ed3334f49c9253bb94cbb7f"></a><!-- doxytag: member="loadcore.h::sceKernelLinkLibraryEntries" ref="ga8f03e8233ed3334f49c9253bb94cbb7f" args="(SceStubLibraryEntryTable *libStubTable, u32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga8f03e8233ed3334f49c9253bb94cbb7f">sceKernelLinkLibraryEntries</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libStubTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Link kernel mode stub libraries with the corresponding registered resident libraries. Note that this function assumes that the resident libraries linked with reside in kernel memory. Linking with user mode resident libraries will result in failure.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">libStubTable</td><td>Pointer to a stub library's entry table. If you want to link an array of entry tables, make libStubTable a pointer to the first element of that array. </td></tr>
    <tr><td class="paramname">size</td><td>The number of entry tables to link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8025675e3f76dd3de33abe290428660c"></a><!-- doxytag: member="loadcore.h::sceKernelUnLinkLibraryEntries" ref="ga8025675e3f76dd3de33abe290428660c" args="(SceStubLibraryEntryTable *libStubTable, u32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga8025675e3f76dd3de33abe290428660c">sceKernelUnLinkLibraryEntries</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libStubTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unlink stub libraries from their corresponding registered resident libraries.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">libStubTable</td><td>Pointer to a stub library's entry table. If you want to unlink an array of entry tables, make libStubTable a pointer to the first element of that array. </td></tr>
    <tr><td class="paramname">size</td><td>The number of entry tables to unlink. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gac154c992eeedc2eaa0088776d44a3cae"></a><!-- doxytag: member="loadcore.h::sceKernelLoadModuleBootLoadCore" ref="gac154c992eeedc2eaa0088776d44a3cae" args="(SceLoadCoreBootModuleInfo *bootModInfo, SceLoadCoreExecFileInfo *execInfo, SceUID *modMemId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gac154c992eeedc2eaa0088776d44a3cae">sceKernelLoadModuleBootLoadCore</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreBootModuleInfo.html">SceLoadCoreBootModuleInfo</a> *&#160;</td>
          <td class="paramname"><em>bootModInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SceUID *&#160;</td>
          <td class="paramname"><em>modMemId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load a module. This function is used to boot modules during the start of Loadcore. In order for a module to be loaded, it has to be a kernel module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bootModInfo</td><td>Pointer to module information (including the file content of the module, its size,...) used to boot the module. </td></tr>
    <tr><td class="paramname">execInfo</td><td>Pointer an allocated execInfo structure used to handle load-checks against the program module. Furthermore, it collects various information about the module, such as its elfType, its segments (.text, .data, .bss), the locations of its exported functions. </td></tr>
    <tr><td class="paramname">modMemId</td><td>The memory id of the allocated kernelPRX memory block used for the program module sections. The memory block specified by the ID holds the .text segment of the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga06690dfe9537a4eb1ab8942d4a5e0a1d"></a><!-- doxytag: member="loadcore.h::sceKernelLoadCoreLock" ref="ga06690dfe9537a4eb1ab8942d4a5e0a1d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga06690dfe9537a4eb1ab8942d4a5e0a1d">sceKernelLoadCoreLock</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Save interrupts state and disable all interrupts.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current state of the interrupt controller. Use <a class="el" href="group__Loadcore.html#gae05f15d19f46b074ae730c86c953db26">sceKernelLoadCoreUnlock()</a> to return to that state. </dd></dl>

</div>
</div>
<a class="anchor" id="gae05f15d19f46b074ae730c86c953db26"></a><!-- doxytag: member="loadcore.h::sceKernelLoadCoreUnlock" ref="gae05f15d19f46b074ae730c86c953db26" args="(s32 intrState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Loadcore.html#gae05f15d19f46b074ae730c86c953db26">sceKernelLoadCoreUnlock</a> </td>
          <td>(</td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>intrState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return interrupt state.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">intrState</td><td>The state acquired by <a class="el" href="group__Loadcore.html#ga06690dfe9537a4eb1ab8942d4a5e0a1d">sceKernelLoadCoreLock()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf43974f8ec77ca5ca2e90e025327fa55"></a><!-- doxytag: member="loadcore.h::sceKernelRegisterLibraryForUser" ref="gaf43974f8ec77ca5ca2e90e025327fa55" args="(SceResidentLibraryEntryTable *libEntryTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gaf43974f8ec77ca5ca2e90e025327fa55">sceKernelRegisterLibraryForUser</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libEntryTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a user mode resident library's entry table in the system. A resident module can register any number of resident libraries. In order to register kernel mode libraries, use <a class="el" href="group__Loadcore.html#ga5e1860bc052008fbebde6907abea5919">sceKernelRegisterLibrary()</a>.</p>
<p>Restrictions on user mode resident libraries: 1) The resident library has to live in user memory. 2) Functions cannot be exported via the SYSCALL technique. 3) The resident library cannot be linked with stub libraries living in kernel memory.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">libEntryTable</td><td>Pointer to the resident library's entry table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ff3206fbd6adf5e7dfb03efb67258e6"></a><!-- doxytag: member="loadcore.h::sceKernelReleaseLibrary" ref="ga1ff3206fbd6adf5e7dfb03efb67258e6" args="(SceResidentLibraryEntryTable *libEntryTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga1ff3206fbd6adf5e7dfb03efb67258e6">sceKernelReleaseLibrary</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libEntryTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a registered resident library from the system. Deletion cannot be performed if there are loaded modules using the resident library. These modules must be deleted first.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">libEntryTable</td><td>Pointer to the resident library's entry table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe06ce57f0c47128178c0d77fd6f3a45"></a><!-- doxytag: member="loadcore.h::sceKernelLinkLibraryEntriesForUser" ref="gafe06ce57f0c47128178c0d77fd6f3a45" args="(SceStubLibraryEntryTable *libStubTable, u32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gafe06ce57f0c47128178c0d77fd6f3a45">sceKernelLinkLibraryEntriesForUser</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libStubTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">libStubTable</td><td>Pointer to a stub library's entry table. If you want to link an array of entry tables, make libStubTable a pointer to the first element of that array. </td></tr>
    <tr><td class="paramname">size</td><td>The number of entry tables to link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f0ad0656e221ae09a1da75722e8e0a2"></a><!-- doxytag: member="loadcore.h::sceKernelLinkLibraryEntriesWithModule" ref="ga8f0ad0656e221ae09a1da75722e8e0a2" args="(SceModule *mod, SceStubLibraryEntryTable *libStubTable, u32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga8f0ad0656e221ae09a1da75722e8e0a2">sceKernelLinkLibraryEntriesWithModule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libStubTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Pointer to a module. Should not be NULL. The module seems not to be used for anything useful. </td></tr>
    <tr><td class="paramname">libStubTable</td><td>Pointer to a stub library's entry table. If you want to link an array of entry tables, make libStubTable a pointer to the first element of that array. </td></tr>
    <tr><td class="paramname">size</td><td>The number of entry tables to link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6247573c87614bff810f3275d45a8a56"></a><!-- doxytag: member="loadcore.h::sceKernelMaskLibraryEntries" ref="ga6247573c87614bff810f3275d45a8a56" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 <a class="el" href="group__Loadcore.html#ga6247573c87614bff810f3275d45a8a56">sceKernelMaskLibraryEntries</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does nothing but a simple return.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga35b67da694093937b29662cb1fa0bd80"></a><!-- doxytag: member="loadcore.h::sceKernelQueryLoadCoreCB" ref="ga35b67da694093937b29662cb1fa0bd80" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceLoadCore.html">SceLoadCore</a>* <a class="el" href="group__Loadcore.html#ga35b67da694093937b29662cb1fa0bd80">sceKernelQueryLoadCoreCB</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get Loadcore's control block. The block takes care of the registered libraries, the unlinked stub libraries living in memory and the currently loaded modules.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to Loadcore's internal control block. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4d5e3489d68d046ec7d07af2d8c6ef4"></a><!-- doxytag: member="loadcore.h::sceKernelSetBootCallbackLevel" ref="gac4d5e3489d68d046ec7d07af2d8c6ef4" args="(SceKernelBootCallbackFunction bootCBFunc, u32 flag, s32 *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gac4d5e3489d68d046ec7d07af2d8c6ef4">sceKernelSetBootCallbackLevel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Loadcore.html#gaaaf9e069ea1f8e0e6a0b70898afc3270">SceKernelBootCallbackFunction</a>&#160;</td>
          <td class="paramname"><em>bootCBFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32 *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a boot callback. Call this function during a module boot process.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bootCBFunc</td><td>The boot callback function to execute once the important system modules (up to init.prx) have been booted. </td></tr>
    <tr><td class="paramname">flag</td><td>Defines the execute order of the callbacks. Pass 0 for earliest execution, 3 for latest. 1 and 2 are between these two. </td></tr>
    <tr><td class="paramname">status</td><td>The returned status of bootCBFunc in case it was executed directly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for directly executing the boot callback function. 1 indicates boot callback function was enqueued into other existing boot callbacks and will be called after init.prx got booted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d6500012c146066884c19e5b2ba4ade"></a><!-- doxytag: member="loadcore.h::sceKernelLoadCoreMode" ref="ga1d6500012c146066884c19e5b2ba4ade" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 <a class="el" href="group__Loadcore.html#ga1d6500012c146066884c19e5b2ba4ade">sceKernelLoadCoreMode</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does nothing but a simple return, probably a debug function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f6a2494ffb0470b0f9599e090e50831"></a><!-- doxytag: member="loadcore.h::sceKernelCheckPspConfig" ref="ga7f6a2494ffb0470b0f9599e090e50831" args="(u8 *file, u32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga7f6a2494ffb0470b0f9599e090e50831">sceKernelCheckPspConfig</a> </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check and decrypt a PSP configuration file.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The configuration file (i.e. pspbtcnf.bin) to decrypt. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the decrypted file on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4085a25a1930eff036090a5102aec28d"></a><!-- doxytag: member="loadcore.h::sceKernelLoadRebootBin" ref="ga4085a25a1930eff036090a5102aec28d" args="(u8 *file, u32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga4085a25a1930eff036090a5102aec28d">sceKernelLoadRebootBin</a> </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrypt and load a reboot file used to boot the system. Reboot.bin is only used for kernel reboots (warm reboots only).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The reboot file to use (i.e. reboot.bin). </td></tr>
    <tr><td class="paramname">size</td><td>The size of the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b218b4b1d73fb5e70245175b9ab3de2"></a><!-- doxytag: member="loadcore.h::sceKernelSegmentChecksum" ref="ga2b218b4b1d73fb5e70245175b9ab3de2" args="(SceModule *mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga2b218b4b1d73fb5e70245175b9ab3de2">sceKernelSegmentChecksum</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute a checksum of every segment of a module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to create the checksum for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The checksum. Shouldn't be 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc44f347ed1d715e36335fefaf55c73d"></a><!-- doxytag: member="loadcore.h::sceKernelCheckExecFile" ref="gadc44f347ed1d715e36335fefaf55c73d" args="(u8 *buf, SceLoadCoreExecFileInfo *execInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gadc44f347ed1d715e36335fefaf55c73d">sceKernelCheckExecFile</a> </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check an executable file. This contains scanning its ELF header and ~PSP header (if it has one) and filling the execInfo structure with basic information, like the ELF type, segment information, the size of the executable. The file is also uncompressed, if it was compressed before.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the file's contents. </td></tr>
    <tr><td class="paramname">execInfo</td><td>Pointer to the executionInfo belonging to that executable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga088333b921044f7835c1d6ec9b2319af"></a><!-- doxytag: member="loadcore.h::sceKernelProbeExecutableObject" ref="ga088333b921044f7835c1d6ec9b2319af" args="(u8 *buf, SceLoadCoreExecFileInfo *execInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga088333b921044f7835c1d6ec9b2319af">sceKernelProbeExecutableObject</a> </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Probe an executable file. This contains calculating the sizes for the three segments TEXT, DATA and BSS, filling the execInfo structure with information about the location and sizes of the resident/stub library entry tables. Furthermore, it is checked whether the executable has valid API type or not.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the file's contents. </td></tr>
    <tr><td class="paramname">execInfo</td><td>Pointer to the executionInfo belonging to that executable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb7052742d9d25460b816091fdebe838"></a><!-- doxytag: member="loadcore.h::sceKernelLoadExecutableObject" ref="gabb7052742d9d25460b816091fdebe838" args="(u8 *buf, SceLoadCoreExecFileInfo *execInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gabb7052742d9d25460b816091fdebe838">sceKernelLoadExecutableObject</a> </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load an executable file. This contains allocating s memory block containing the three segments TEXT, DATA and BSS (in case the executable consists of only these three sections). Furthermore, relocation of the executable file, if needed, is also taken care off.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the file's contents. </td></tr>
    <tr><td class="paramname">execInfo</td><td>Pointer to the executionInfo belonging to that executable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gadaf7561a272d3b2cf5affab96c72145e"></a><!-- doxytag: member="loadcore.h::sceKernelCreateModule" ref="gadaf7561a272d3b2cf5affab96c72145e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* <a class="el" href="group__Loadcore.html#gadaf7561a272d3b2cf5affab96c72145e">sceKernelCreateModule</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate memory for a new <a class="el" href="structSceModule.html">SceModule</a> structure and fill it with default values. This function is called during the loading process of a module.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaaf39d993dcafa17af01e1ca7c194a18"></a><!-- doxytag: member="loadcore.h::sceKernelAssignModule" ref="gaaaf39d993dcafa17af01e1ca7c194a18" args="(SceModule *mod, SceLoadCoreExecFileInfo *execFileInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gaaaf39d993dcafa17af01e1ca7c194a18">sceKernelAssignModule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execFileInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a module and check if it can be loaded, is a valid module and copy the moduleInfo section of the execution file over to the <a class="el" href="structSceModule.html">SceModule</a> structure.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to receive the moduleInfo section data based on the provided execution file information. </td></tr>
    <tr><td class="paramname">execFileInfo</td><td>The execution file information used to copy over the moduleInfo section for the specified module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2413650b3190085fd16d5e0e8f501e1"></a><!-- doxytag: member="loadcore.h::sceKernelReleaseModule" ref="gac2413650b3190085fd16d5e0e8f501e1" args="(SceModule *mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gac2413650b3190085fd16d5e0e8f501e1">sceKernelReleaseModule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unlink a module from the internal loaded-modules-linked-list. The module has to be stopped before.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gae9cffa3669a80cbdb0fec14c7cc1b3ee"></a><!-- doxytag: member="loadcore.h::sceKernelGetModuleIdListForKernel" ref="gae9cffa3669a80cbdb0fec14c7cc1b3ee" args="(SceUID *modIdList, u32 size, u32 *modCount, u32 userModsOnly)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gae9cffa3669a80cbdb0fec14c7cc1b3ee">sceKernelGetModuleIdListForKernel</a> </td>
          <td>(</td>
          <td class="paramtype">SceUID *&#160;</td>
          <td class="paramname"><em>modIdList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>modCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>userModsOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive a list of UIDs of loaded modules.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">modIdList</td><td>Pointer to a SceUID array which will receive the UIDs of the loaded modules. </td></tr>
    <tr><td class="paramname">size</td><td>Size of modIdList. Specifies the number of entries that can be stored into modIdList. </td></tr>
    <tr><td class="paramname">modCount</td><td>A pointer which will receive the total number of loaded modules. </td></tr>
    <tr><td class="paramname">userModsOnly</td><td>Set to 1 to only receive UIDs from user mode modules. Set to 0 to receive UIDs from all loaded modules.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30d19f5c2935c6f97b48c6e106c7a34c"></a><!-- doxytag: member="loadcore.h::sceKernelGetModuleFromUID" ref="ga30d19f5c2935c6f97b48c6e106c7a34c" args="(SceUID uid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* <a class="el" href="group__Loadcore.html#ga30d19f5c2935c6f97b48c6e106c7a34c">sceKernelGetModuleFromUID</a> </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a loaded module from its UID.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>The UID (of a module) to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the found <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f953301858af828e5e11084c3e2806f"></a><!-- doxytag: member="loadcore.h::sceKernelDeleteModule" ref="ga4f953301858af828e5e11084c3e2806f" args="(SceModule *mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga4f953301858af828e5e11084c3e2806f">sceKernelDeleteModule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a module from the system. The module has to be stopped and released before.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gabac93803cbf0181b02ab23d7d7220040"></a><!-- doxytag: member="loadcore.h::sceKernelCreateAssignModule" ref="gabac93803cbf0181b02ab23d7d7220040" args="(SceLoadCoreExecFileInfo *execFileInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* <a class="el" href="group__Loadcore.html#gabac93803cbf0181b02ab23d7d7220040">sceKernelCreateAssignModule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execFileInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create and assign a module. It provides the same result as a <a class="el" href="group__Loadcore.html#gadaf7561a272d3b2cf5affab96c72145e">sceKernelCreateModule()</a> call followed by a <a class="el" href="group__Loadcore.html#gaaaf39d993dcafa17af01e1ca7c194a18">sceKernelAssignModule()</a> call.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">execFileInfo</td><td>The execution file information used to copy over the moduleInfo section for the specified module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the created <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga78f11263a69a222a15be9977fce1af50"></a><!-- doxytag: member="loadcore.h::sceKernelRegisterModule" ref="ga78f11263a69a222a15be9977fce1af50" args="(SceModule *mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#ga78f11263a69a222a15be9977fce1af50">sceKernelRegisterModule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a module in the system and link it into the internal loaded-modules-linked-list.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="gaebbaa6caea1fe4f07e4f0a9436f67147"></a><!-- doxytag: member="loadcore.h::sceKernelFindModuleByName" ref="gaebbaa6caea1fe4f07e4f0a9436f67147" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* <a class="el" href="group__Loadcore.html#gaebbaa6caea1fe4f07e4f0a9436f67147">sceKernelFindModuleByName</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a loaded module by its name. If more than one module with the same name is loaded, return the module which was loaded last.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the module to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the found <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60135c1de86354096f49bc42360c8c6a"></a><!-- doxytag: member="loadcore.h::sceKernelFindModuleByAddress" ref="ga60135c1de86354096f49bc42360c8c6a" args="(u32 addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* <a class="el" href="group__Loadcore.html#ga60135c1de86354096f49bc42360c8c6a">sceKernelFindModuleByAddress</a> </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a loaded module containing the specified address.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Memory address belonging to the module, i.e. the address of a function/global variable within the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the found <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gabc7d802b414800306356518437437ea8"></a><!-- doxytag: member="loadcore.h::sceKernelGetModuleGPByAddressForKernel" ref="gabc7d802b414800306356518437437ea8" args="(u32 addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 <a class="el" href="group__Loadcore.html#gabc7d802b414800306356518437437ea8">sceKernelGetModuleGPByAddressForKernel</a> </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the global pointer value of a module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Memory address belonging to the module, i.e. the address of a function/global variable within the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The global pointer value (greater than 0) of the found module on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gad7965536d1d3b54d72836100caf6b57d"></a><!-- doxytag: member="loadcore.h::sceKernelFindModuleByUID" ref="gad7965536d1d3b54d72836100caf6b57d" args="(SceUID uid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* <a class="el" href="group__Loadcore.html#gad7965536d1d3b54d72836100caf6b57d">sceKernelFindModuleByUID</a> </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a loaded module by its UID.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>The UID of the module to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the found <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga55a39d58f03c98c1e7deee348c218ed8"></a><!-- doxytag: member="loadcore.h::sceKernelGetModuleListWithAlloc" ref="ga55a39d58f03c98c1e7deee348c218ed8" args="(u32 *modCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SceUID <a class="el" href="group__Loadcore.html#ga55a39d58f03c98c1e7deee348c218ed8">sceKernelGetModuleListWithAlloc</a> </td>
          <td>(</td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>modCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive a list of UIDs of all loaded modules.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">modCount</td><td>A pointer which will receive the total number of loaded modules.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The UID of the allocated array containing UIDs of the loaded modules on success. It should be greater than 0. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 27 2015 19:05:30 for uOFW by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
